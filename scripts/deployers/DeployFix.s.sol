// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import {Script, stdJson, console} from "forge-std/Script.sol";

// These imports get generated by npm run generate:interfaces
import {Registry} from "../helpers/interfaces/Registry.generated.sol";
import {Timelock} from "../helpers/interfaces/Timelock.generated.sol";
import {Governance} from "../helpers/interfaces/Governance.generated.sol";
import {WithdrawManagerProxy} from "../helpers/interfaces/WithdrawManagerProxy.generated.sol";


contract DeployFix is Script {
    using stdJson for string;

    Timelock timelock = Timelock(0xCaf0aa768A3AE1297DF20072419Db8Bb8b5C8cEf);
    Registry registry = Registry(0x33a02E6cC863D393d6Bf231B697b82F6e499cA71);

    // owned by 0xfa7d2a996ac6350f4b56c043112da0366a59b74c
    address governance = 0x6e7a5820baD6cebA8Ef5ea69c0C92EbbDAc9CE48;

    address gSafeAddress = 0xfa7d2a996ac6350f4b56c043112da0366a59b74c;

    // non upgradeable
    // FxMintableERC20RootTunnel 
    // FxERC1155RootTunnel
    // FxERC721RootTunnel
    // FxERC20RootTunnel
    // from pos-portal

    // owned by 0xfa7d2a996ac6350f4b56c043112da0366a59b74c
    address withdrawManagerProxy = 0x2A88696e0fFA76bAA1338F2C74497cC013495922;

    address withdrawManager;
    address eRC20PredicateBurnOnly;
    address eRC721PredicateBurnOnly;
    address mintableERC721Predicate;


    // //pos

    // owned by 0xfa7d2a996ac6350f4b56c043112da0366a59b74c
    // RootChainManagerProxy
    // RootChainManager
    // // pending check

    // owned by 0xfa7d2a996ac6350f4b56c043112da0366a59b74c
    // ERC20PredicateProxy
    // owned by 0xfa7d2a996ac6350f4b56c043112da0366a59b74c
    // ERC721PredicateProxy
    // owned by 0xfa7d2a996ac6350f4b56c043112da0366a59b74c
    // ERC1155PredicateProxy
    // owned by 0xfa7d2a996ac6350f4b56c043112da0366a59b74c
    // MintableERC20PredicateProxy
    // owned by 0xfa7d2a996ac6350f4b56c043112da0366a59b74c
    // MintableERC721PredicateProxy
    // owned by 0xfa7d2a996ac6350f4b56c043112da0366a59b74c
    // MintableERC1155PredicateProxy
    // owned by 0xfa7d2a996ac6350f4b56c043112da0366a59b74c
    // EtherPredicateProxy

    function run() public {
        uint256 deployerPrivateKey = vm.promptSecretUint("Enter deployer private key: ");
        //uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");


        vm.startBroadcast(deployerPrivateKey);

        // deploy STEP 1
        // deploy new WithdrawManager version
        withdrawManager = deployCode("out/WithdrawManager.sol/WithdrawManager.json"));

        console.log("deployed WithdrawManager implementation at: ", withdrawManager);

        // deploy STEP 2
        // deploy new ERC20PredicateBurnOnly version
        eRC20PredicateBurnOnly = deployCode("out/ERC20PredicateBurnOnly.sol/ERC20PredicateBurnOnly.json");

        console.log("deployed ERC20PredicateBurnOnly implementation at: ", eRC20PredicateBurnOnly);

        // deploy STEP 3
        // deploy new ERC721PredicateBurnOnly version
        eRC721PredicateBurnOnly = deployCode("out/ERC721PredicateBurnOnly.sol/ERC721PredicateBurnOnly.json");

        console.log("deployed ERC721PredicateBurnOnly implementation at: ", eRC721PredicateBurnOnly);

        // deploy STEP 4
        // deploy new ERC721PredicateBurnOnly version
        mintableERC721Predicate = deployCode("out/MintableERC721Predicate.sol/MintableERC721Predicate.json");

        console.log("deployed MintableERC721Predicate implementation at: ", mintableERC721Predicate);

        vm.stopBroadcast();
   
        console.log("----------------------");
        console.log("Generating payloads \n");

        // STEP 1
        // Remove predicates
        bytes memory payloadRegistry1 = abi.encodeCall(
            Governance.update, (address(registry), abi.encodeCall(Registry.removePredicate, (0x158d5fa3ef8e4dda8a5367decf76b94e7effce95)))
        );
        bytes memory payloadRegistry2 = abi.encodeCall(
            Governance.update, (address(registry), abi.encodeCall(Registry.removePredicate, (0x54150f44c785d412ec262fe895cc3b689c72f49b)))
        );
        bytes memory payloadRegistry3 = abi.encodeCall(
            Governance.update, (address(registry), abi.encodeCall(Registry.removePredicate, (0x932532aA4c0174b8453839A6E44eE09Cc615F2b7)))
        );

        // STEP 2
        // Add predicates
        bytes memory payloadRegistry4 = abi.encodeCall(
            Governance.update, (address(registry), abi.encodeCall(Registry.addErc20Predicate, (eRC20PredicateBurnOnly)))
        );
        bytes memory payloadRegistry5 = abi.encodeCall(
            Governance.update, (address(registry), abi.encodeCall(Registry.addErc721Predicate, (eRC721PredicateBurnOnly)))
        );
        bytes memory payloadRegistry6 = abi.encodeCall(
            Governance.update, (address(registry), abi.encodeCall(Registry.addErc721Predicate, (mintableERC721Predicate)))
        );

        // STEP 3
        // Update WithdrawManagerProxy implementation contract
        bytes memory payloadWithdrawManager = abi.encodeCall(WithdrawManagerProxy.updateImplementation, (withdrawManager));


        console.log("----------------------");
        console.log("Batching payloads \n");

        address[] memory targets = new address[](7);
        targets[0] = address(governance);
        targets[1] = address(governance);
        targets[2] = address(governance);
        targets[3] = address(governance);
        targets[4] = address(governance);
        targets[5] = address(governance);
        targets[6] = address(withdrawManagerProxy);

        // Inits to 0
        uint256[] memory values = new uint256[](7);

        bytes[] memory payloads = new bytes[](7);
        payloads[0] = payloadRegistry1;
        payloads[1] = payloadRegistry2;
        payloads[2] = payloadRegistry3;
        payloads[3] = payloadRegistry4;
        payloads[4] = payloadRegistry5;
        payloads[5] = payloadRegistry6;
        payloads[6] = payloadWithdrawManager;

        // 172800 is minDelay (2 days)
        scheduleBatchPayload = abi.encodeCall(Timelock.scheduleBatch, (targets, values, payloads, "", "", 0));
        executeBatchPayload = abi.encodeCall(Timelock.executeBatch, (targets, values, payloads, "", ""));
    }
}
